<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visor IFC Profesional</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
        }
        
        #viewer-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #toolbar { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            z-index: 100; 
            background: white; 
            padding: 20px; 
            border-radius: 10px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            min-width: 300px;
        }
        
        #toolbar h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
        }
        
        #ifcInput {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            background: #f8f9fa;
        }
        
        #ifcInput:hover {
            border-color: #4CAF50;
            background: white;
        }
        
        #status {
            margin-top: 12px;
            padding: 12px;
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .loading { 
            background: #fff3cd; 
            color: #856404;
        }
        
        .success { 
            background: #d4edda; 
            color: #155724;
        }
        
        .error { 
            background: #f8d7da; 
            color: #721c24;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
        }
        
        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="viewer-container">
        <div id="toolbar">
            <h3>üèóÔ∏è Visor IFC Profesional</h3>
            <input type="file" id="ifcInput" accept=".ifc" disabled>
            <div id="status" class="loading">
                <div class="spinner"></div>
                Cargando bibliotecas...
            </div>
        </div>
        <div id="canvas-container"></div>
    </div>

    <script>
        const container = document.getElementById('canvas-container');
        const statusEl = document.getElementById('status');
        const fileInput = document.getElementById('ifcInput');
        
        function showStatus(message, type = 'loading') {
            statusEl.innerHTML = message;
            statusEl.className = type;
        }

        // Cargar scripts din√°micamente
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // Inicializar todo
        async function init() {
            try {
                showStatus('<div class="spinner"></div>Cargando Three.js...', 'loading');
                await loadScript('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js');
                
                showStatus('<div class="spinner"></div>Cargando controles...', 'loading');
                await loadScript('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js');
                
                showStatus('<div class="spinner"></div>Cargando motor IFC...', 'loading');
                await loadScript('https://unpkg.com/web-ifc@0.0.34/web-ifc-api-browser.js');
                
                // Verificar que todo est√© disponible
                if (typeof THREE === 'undefined') throw new Error('THREE.js no disponible');
                if (typeof THREE.OrbitControls === 'undefined') throw new Error('OrbitControls no disponible');
                if (typeof WebIFC === 'undefined') throw new Error('WebIFC no disponible');
                
                showStatus('<div class="spinner"></div>Inicializando visor 3D...', 'loading');
                await setupViewer();
                
            } catch (error) {
                console.error('Error de inicializaci√≥n:', error);
                showStatus('‚ùå Error: ' + error.message, 'error');
            }
        }

        async function setupViewer() {
            // Escena
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);

            // C√°mara
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(15, 15, 15);

            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Controles
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2;
            controls.minDistance = 5;
            controls.maxDistance = 500;

            // Luces
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(50, 50, 50);
            sunLight.castShadow = true;
            scene.add(sunLight);

            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-30, 30, -30);
            scene.add(fillLight);

            // Grid
            const gridHelper = new THREE.GridHelper(200, 50, 0x555555, 0x333333);
            scene.add(gridHelper);

            // Axes
            const axesHelper = new THREE.AxesHelper(10);
            scene.add(axesHelper);

            // Inicializar IFC API
            showStatus('<div class="spinner"></div>Inicializando motor IFC...', 'loading');
            
            const ifcAPI = new WebIFC.IfcAPI();
            
            // CR√çTICO: Apuntar a la carpeta wasm/ local
            ifcAPI.SetWasmPath('./wasm/');
            
            try {
                await ifcAPI.Init();
                console.log('‚úÖ IFC API inicializada correctamente');
            } catch (error) {
                console.error('‚ùå Error inicializando IFC API:', error);
                showStatus('‚ùå Error: No se pudieron cargar los archivos WASM.<br><small>Aseg√∫rate de que la carpeta wasm/ existe con los archivos correctos.</small>', 'error');
                return;
            }

            let currentModel = null;

            // Funci√≥n para cargar IFC
            async function loadIFC(file) {
                showStatus('<div class="spinner"></div>Leyendo ' + file.name + '...', 'loading');

                // Limpiar modelo anterior
                if (currentModel) {
                    scene.remove(currentModel);
                    currentModel.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                    currentModel = null;
                }

                try {
                    const data = await file.arrayBuffer();
                    const uint8Array = new Uint8Array(data);

                    showStatus('<div class="spinner"></div>Procesando geometr√≠a IFC...', 'loading');

                    const modelID = ifcAPI.OpenModel(uint8Array);
                    const geometries = [];

                    ifcAPI.StreamAllMeshes(modelID, (mesh) => {
                        const geometry = new THREE.BufferGeometry();
                        
                        const positions = ifcAPI.GetGeometry(modelID, mesh.geometryExpressID);
                        const verts = ifcAPI.GetVertexArray(positions.GetVertexData(), positions.GetVertexDataSize());
                        const indices = ifcAPI.GetIndexArray(positions.GetIndexData(), positions.GetIndexDataSize());

                        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(verts), 3));
                        geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
                        geometry.computeVertexNormals();

                        const color = mesh.color || { x: 0.8, y: 0.8, z: 0.8, w: 1 };
                        const material = new THREE.MeshPhongMaterial({
                            color: new THREE.Color(color.x, color.y, color.z),
                            side: THREE.DoubleSide,
                            transparent: color.w < 1,
                            opacity: color.w
                        });

                        const meshObj = new THREE.Mesh(geometry, material);
                        
                        if (mesh.transform) {
                            const matrix = new THREE.Matrix4();
                            matrix.fromArray(mesh.transform);
                            meshObj.applyMatrix4(matrix);
                        }

                        geometries.push(meshObj);
                    });

                    showStatus('<div class="spinner"></div>Ensamblando modelo (' + geometries.length + ' elementos)...', 'loading');

                    const ifcGroup = new THREE.Group();
                    geometries.forEach(mesh => ifcGroup.add(mesh));

                    currentModel = ifcGroup;
                    scene.add(ifcGroup);

                    // Centrar c√°mara
                    const box = new THREE.Box3().setFromObject(ifcGroup);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    gridHelper.position.y = box.min.y - 0.1;
                    controls.target.copy(center);

                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let distance = Math.abs(maxDim / Math.tan(fov / 2)) * 1.8;

                    const direction = new THREE.Vector3(1, 0.8, 1).normalize();
                    camera.position.copy(center).add(direction.multiplyScalar(distance));
                    camera.lookAt(center);
                    controls.update();

                    ifcAPI.CloseModel(modelID);

                    showStatus('‚úÖ <strong>' + file.name + '</strong> cargado exitosamente<br><small>' + geometries.length + ' elementos procesados</small>', 'success');
                    
                    setTimeout(() => { 
                        statusEl.style.display = 'none'; 
                    }, 5000);

                } catch (error) {
                    console.error('Error cargando IFC:', error);
                    showStatus('‚ùå Error al cargar el archivo: ' + error.message, 'error');
                }
            }

            // Evento de archivo
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) loadIFC(file);
            });

            // Responsive
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Animaci√≥n
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }

            animate();

            // Habilitar input y mostrar √©xito
            fileInput.disabled = false;
            showStatus('‚úÖ <strong>Visor listo</strong><br><small>Selecciona un archivo IFC para visualizar</small>', 'success');
            setTimeout(() => { 
                statusEl.style.display = 'none'; 
            }, 4000);
        }

        // Iniciar carga
        init();
    </script>
</body>
</html>
