<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visor IFC Profesional</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
        }
        
        #viewer-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #toolbar { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            z-index: 100; 
            background: white; 
            padding: 20px; 
            border-radius: 10px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            min-width: 280px;
        }
        
        #toolbar h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 16px;
        }
        
        #ifcInput {
            width: 100%;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        
        #ifcInput:hover {
            border-color: #4CAF50;
        }
        
        #status {
            margin-top: 12px;
            padding: 10px;
            border-radius: 6px;
            font-size: 13px;
            display: none;
            font-weight: 500;
        }
        
        .loading { 
            background: #fff3cd; 
            color: #856404;
            display: block !important;
        }
        
        .success { 
            background: #d4edda; 
            color: #155724;
            display: block !important;
        }
        
        .error { 
            background: #f8d7da; 
            color: #721c24;
            display: block !important;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="viewer-container">
        <div id="toolbar">
            <h3>üèóÔ∏è Visor IFC</h3>
            <input type="file" id="ifcInput" accept=".ifc">
            <div id="status"></div>
        </div>
        <div id="canvas-container"></div>
    </div>

    <!-- Three.js r128 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- web-ifc desde unpkg (m√°s confiable) -->
    <script src="https://unpkg.com/web-ifc@0.0.36/web-ifc-api.js"></script>

    <script>
        const container = document.getElementById('canvas-container');
        const statusEl = document.getElementById('status');
        const fileInput = document.getElementById('ifcInput');
        
        function showStatus(message, type = 'loading') {
            statusEl.textContent = message;
            statusEl.className = type;
            statusEl.style.display = 'block';
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // Esperar a que carguen todos los scripts
        let checkInterval = setInterval(() => {
            if (typeof THREE !== 'undefined' && 
                typeof THREE.OrbitControls !== 'undefined' && 
                typeof WebIFC !== 'undefined') {
                
                clearInterval(checkInterval);
                console.log('‚úì Todos los scripts cargados');
                initViewer();
            }
        }, 100);

        // Timeout de seguridad
        setTimeout(() => {
            if (typeof WebIFC === 'undefined') {
                clearInterval(checkInterval);
                showStatus('‚úó Error: WebIFC no se pudo cargar', 'error');
                console.error('WebIFC no disponible despu√©s de 10 segundos');
            }
        }, 10000);

        function initViewer() {
            showStatus('Inicializando visor 3D...', 'loading');

            console.log('THREE disponible:', typeof THREE !== 'undefined');
            console.log('OrbitControls disponible:', typeof THREE.OrbitControls !== 'undefined');
            console.log('WebIFC disponible:', typeof WebIFC !== 'undefined');

            // Escena
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);

            // C√°mara
            const camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                2000
            );
            camera.position.set(15, 15, 15);

            // Renderer
            const renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Controles
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2;
            controls.minDistance = 5;
            controls.maxDistance = 500;

            // Luces
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(50, 50, 50);
            sunLight.castShadow = true;
            scene.add(sunLight);

            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-30, 30, -30);
            scene.add(fillLight);

            // Grid
            const gridHelper = new THREE.GridHelper(200, 50, 0x555555, 0x333333);
            scene.add(gridHelper);

            // Axes
            const axesHelper = new THREE.AxesHelper(10);
            scene.add(axesHelper);

            // Variables IFC
            let ifcAPI;
            let currentModel = null;

            async function initIFC() {
                showStatus('Inicializando motor IFC...', 'loading');
                try {
                    ifcAPI = new WebIFC.IfcAPI();
                    ifcAPI.SetWasmPath('https://unpkg.com/web-ifc@0.0.36/');
                    await ifcAPI.Init();
                    
                    showStatus('‚úì Visor listo. Selecciona un archivo IFC', 'success');
                    setTimeout(() => {
                        statusEl.style.display = 'none';
                    }, 3000);
                } catch (error) {
                    console.error('Error inicializando IFC:', error);
                    showStatus('‚úó Error: ' + error.message, 'error');
                }
            }

            // Funci√≥n para cargar IFC
            async function loadIFC(file) {
                if (!ifcAPI) {
                    showStatus('‚úó Motor IFC no inicializado', 'error');
                    return;
                }

                showStatus(`Leyendo ${file.name}...`, 'loading');

                // Limpiar modelo anterior
                if (currentModel) {
                    scene.remove(currentModel);
                    if (currentModel.traverse) {
                        currentModel.traverse((child) => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => m.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        });
                    }
                    currentModel = null;
                }

                try {
                    const data = await file.arrayBuffer();
                    const uint8Array = new Uint8Array(data);

                    showStatus('Procesando geometr√≠a...', 'loading');

                    const modelID = ifcAPI.OpenModel(uint8Array);
                    const geometries = [];

                    ifcAPI.StreamAllMeshes(modelID, (mesh) => {
                        const geometry = new THREE.BufferGeometry();
                        
                        const positions = ifcAPI.GetGeometry(modelID, mesh.geometryExpressID);
                        const verts = ifcAPI.GetVertexArray(positions.GetVertexData(), positions.GetVertexDataSize());
                        const indices = ifcAPI.GetIndexArray(positions.GetIndexData(), positions.GetIndexDataSize());

                        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(verts), 3));
                        geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
                        geometry.computeVertexNormals();

                        const color = mesh.color || { x: 0.8, y: 0.8, z: 0.8, w: 1 };
                        const material = new THREE.MeshPhongMaterial({
                            color: new THREE.Color(color.x, color.y, color.z),
                            side: THREE.DoubleSide,
                            transparent: color.w < 1,
                            opacity: color.w
                        });

                        const meshObj = new THREE.Mesh(geometry, material);
                        
                        if (mesh.transform) {
                            const matrix = new THREE.Matrix4();
                            matrix.fromArray(mesh.transform);
                            meshObj.applyMatrix4(matrix);
                        }

                        geometries.push(meshObj);
                    });

                    showStatus('Ensamblando modelo...', 'loading');

                    const ifcGroup = new THREE.Group();
                    geometries.forEach(mesh => ifcGroup.add(mesh));

                    currentModel = ifcGroup;
                    scene.add(ifcGroup);

                    // Centrar
                    const box = new THREE.Box3().setFromObject(ifcGroup);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    gridHelper.position.y = box.min.y - 0.1;
                    controls.target.copy(center);

                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let distance = Math.abs(maxDim / Math.tan(fov / 2)) * 1.8;

                    const direction = new THREE.Vector3(1, 0.8, 1).normalize();
                    camera.position.copy(center).add(direction.multiplyScalar(distance));
                    camera.lookAt(center);
                    controls.update();

                    ifcAPI.CloseModel(modelID);

                    showStatus(`‚úì Cargado: ${geometries.length} elementos`, 'success');
                    setTimeout(() => { statusEl.style.display = 'none'; }, 4000);

                } catch (error) {
                    console.error('Error cargando IFC:', error);
                    showStatus(`‚úó Error: ${error.message}`, 'error');
                }
            }

            // Evento
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) loadIFC(file);
            });

            // Responsive
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Animaci√≥n
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }

            // Iniciar
            initIFC().then(() => animate());
        }
    </script>
</body>
</html>
